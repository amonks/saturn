{"version":3,"sources":["save.js"],"names":[],"mappings":";;;;;;AAIA,MAAM,CAAC,IAAI,GAAG,YAAY;;AAExB,MAAI,GAAG,GAAG,EAAE,CAAA;;AAEZ,KAAG,CAAC,eAAe,GAAG,UAAU,MAAM,EAAE,QAAQ,EAAE;AAChD,QAAI,GAAG,GAAG,8BAA8B,GAAG,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAA;AACrF,WAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AAChB,OAAG,CAAC,iBAAiB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAA;GACrC,CAAA;;;;AAID,KAAG,CAAC,iBAAiB,GAAG,UAAU,OAAO,EAAE,QAAQ,EAAE;AACnD,QAAI,OAAO,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAA;AACzC,QAAI,IAAI,GAAG,CAAC,CAAC,WAAW,GAAG,OAAO,GAAG,4BAA4B,GAAG,QAAQ,GAAG,yBAAyB,CAAC,CAAA;AACzG,KAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;AACtB,KAAC,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAA;GAC9B,CAAA;;;;;AAKD,MAAI,kBAAkB,GAAG,SAArB,kBAAkB,CAAa,OAAO,EAAE;AAC1C,QAAI,IAAI,GAAG,SAAS,CAAC,OAAO,CAAC,CAAA;AAC7B,QAAI,OAAO,GAAG,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAA;AACvC,WAAO,OAAO,CAAA;GACf,CAAA;;;;;AAKD,MAAI,SAAS,GAAG,SAAZ,SAAS,CAAa,OAAO,EAAE;;;AAGjC,QAAI,UAAU,CAAA;AACd,QAAI,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AAChD,gBAAU,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;KACtD,MAAM;AACL,gBAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;KAC7C;;AAED,QAAI,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAA;;;AAGlE,QAAI,EAAE,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,CAAA;AAC3C,QAAI,EAAE,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAA;AAC3B,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC1C,QAAE,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;KACjC;;;AAGD,WAAO,IAAI,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE;AACpB,UAAI,EAAE,UAAU;KACjB,CAAC,CAAA;GACH,CAAA;;AAED,SAAO,GAAG,CAAA;CACX,CAAA","file":"save.js","sourcesContent":["// save.js\n\n/* global WindowBase64 Blob URL JSON $ */\n\nwindow.Save = function () {\n\n  let API = {}\n\n  API.download_object = function (object, filename) {\n    let url = 'data:text/json;charset=utf8,' + encodeURIComponent(JSON.stringify(object))\n    console.log(url)\n    API.download_data_uri(url, filename)\n  }\n\n  // function to force-download from a data uri as a filename\n  // nb the download=\"filename\" attribute isn't yet supported by safari\n  API.download_data_uri = function (dataURI, fileName) {\n    var tempUrl = make_url_from_data(dataURI)\n    var link = $('<a href=\"' + tempUrl + '\" id=\"download\" download=\"' + fileName + '\" target=\"_blank\"> </a>')\n    $('body').append(link)\n    $('#download').get(0).click()\n  }\n\n  // function to generate a temporary browser index url for a datauri\n  // if a data-uri is larger than 2mb, chrome's address bar can't handle it.\n  // fortunately, you can blob it and then use a temporary blob url\n  let make_url_from_data = function (dataURI) {\n    var blob = make_blob(dataURI)\n    var tempUrl = URL.createObjectURL(blob)\n    return tempUrl\n  }\n\n  // function to convert a datauri to a blob\n  // I'm not totally sure what a blob is, but apparantly they can hold binary data and generate temporary urls.\n  // start process\n  let make_blob = function (dataURI) {\n    // convert base64 to raw binary data held in a string\n    // doesn't handle URLEncoded DataURIs\n    var byteString\n    if (dataURI.split(',')[0].indexOf('base64') >= 0) {\n      byteString = WindowBase64.atob(dataURI.split(',')[1])\n    } else {\n      byteString = unescape(dataURI.split(',')[1])\n    }\n    // separate out the mime component\n    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]\n\n    // write the bytes of the string to an ArrayBuffer\n    var ab = new ArrayBuffer(byteString.length)\n    var ia = new Uint8Array(ab)\n    for (var i = 0; i < byteString.length; i++) {\n      ia[i] = byteString.charCodeAt(i)\n    }\n\n    // write the ArrayBuffer to a blob, and you're done\n    return new Blob([ab], {\n      type: mimeString\n    })\n  }\n\n  return API\n}\n"],"sourceRoot":"/source/"}